目录：

* [合约结构](#合约结构)
  * [智能合约文件结构](#智能合约文件结构)
  * [智能合约源文件基本要素概览](#智能合约源文件基本要素概览)
    * [状态变量](#状态变量)
    * [函数](#函数)
    * [函数修饰符](#函数修饰符)
    * [事件](#事件)
    * [错误](#错误)
    * [结构体](#结构体)
    * [枚举](#枚举)
    * [映射](#映射)
    * [库](#库)
    * [接口](#接口)

* [类型](#leixing)
  * [值类型](#值类型)
    * [布尔型](#布尔型)
    * [整数](#整数)
    * [地址](#地址)
    * [字节数组](#字节数组)
    * [小数](#小数)
    * [字符串](#字符串)
    * [枚举](#枚举)
    * [函数类型](#函数类型)
  * [引用类型](#引用类型)
    * [数据位置](#数据位置)
    * [数组](#数组)
    * [结构体](#结构体)
  * [映射](#映射)
  * 操作符
  * [基本类型之间的转换](#基本类型之间的转换)
  * 字面常量与基本类型的转换
* [单位和全局变量](#单位和全局变量)
  * [货币单位](#货币单位)
  * [时间单位](#时间单位)
  * [特殊变量和函数](#特殊变量和函数)

* 表达式和控制结构
* [智能合约](#智能合约)
  * [合约概述](#合约概述)
  * [创建合约](#创建合约)
  * [可见性和getter函数](#可见性和getter函数)
  * [函数修饰器](#函数修饰器)
  * [Constant和Immutable状态变量](#Constant和Immutable状态变量)
  * [构造函数](#构造函数)
  * [函数](#函数)
  * [事件](#事件)
  * [继承](#继承)
  * [抽象合约](#抽象合约)
  * [接口](#接口)
  * [库](#库)


<a id="合约结构"></a>

## 合约结构

<a id="智能合约文件结构"></a>

### 智能合约文件结构

#### 版本申明

```text
pragma solidity ^0.4.0；
```

说明：
1 版本要高于0.4才可以编译
2 号表示高于0.5的版本则不可编译，第三位的版本号但可以变，留出来用做bug可以修复（如0.4.1的编译器有bug，可在0.4.2修复，现有合约不用改代码）。

#### 引用其它源文件

- 全局引入 *

```text
import “filename”;
```

- 自定义命名空间引入 *

```text
import * as symbolName from “filename”
```

分别定义引入

```text
import  {symbol1 as alias, symbol2} from “filename”
```

非es6兼容的简写语法

```text
import “filename” as symbolName
```

等同于上述

```text
import * as symbolName from “filename”
```

**关于路径**

引入文件路径时要注意，非`.`打头的路径会被认为是绝对路径，所以要引用同目录下的文件使用

```text
import “./x” as x
```

也不要使用下述方式，这样会是在一个全局的目录下

```text
import “x” as x;
```

为什么会有这个区别，是因为这取决于编译器，如果解析路径，通常来说目录层级结构并不与我们本地的文件一一对应，它非常有可能是通过ipfs,http，或git建立的一个网络上的虚拟目录。

#### 编译器解析引用文件机制

各编译器提供了文件前缀映射机制。

1. 可以将一个域名下的文件映射到本地，从而从本地的某个文件中读取
2. 提供对同一实现的不同版本的支持（可能某版本的实现前后不兼容，需要区分）
3. 如果前缀相同，取最长，
4. 有一个”fallback-remapping”机制，空串会映射到“/usr/local/include/solidify”

#### solc编译器

命令行编译器，通过下述命令命名空间映射提供支持

```text
context:prefix=target
```

上述的`context:`和`=target`是可选的。所有`context`目录下的以`prefix`开头的会被替换为`target`。
举例来说，如果你将`github.com/ethereum/dapp-bin`拷到本地的`/usr/local/dapp-bin`，并使用下述方式使用文件

```text
import “github.com/ethereum/dapp-bin/library/iterable_mapping.sol” as it_mapping;
```

要编译这个文件，使用下述命令：

```text
solc github.com/ethereum/dapp-bin=/usr/local/dapp-bin source.sol
```

另一个更复杂的例子，如果你使用一个更旧版本的dapp-bin，旧版本在/url/local/dapp-bin_old，那么，你可以使用下述命令编译

```text
solc module1:github.com/ethereum/dapp-bin=/usr/local/dapp-bin  \
        modeule2:github.com/ethereum/dapp-bin=/usr/local/dapp-bin_old \
        source.sol
```

需要注意的是solc仅仅允许包含实际存在的文件。它必须存在于你重映射后目录里，或其子目录里。如果你想包含直接的绝对路径包含，那么可以将命名空间重映射为`=\`
备注：如果有多个重映射指向了同一个文件，那么取最长的那个文件。

#### 代码注释

两种方式,单行（`//`）,多行使用(`/*…*/`)

*示例*

```text
// this is a single-line comment
/*
this is a
mulit-line comment
*/
```

#### 文档注释

写文档用。三个斜杠`///`或`/** … */`，可使用`Doxygen`语法，以支持生成对文档的说明，参数验证的注解，或者是在用户调用这个函数时，弹出来的确认内容。

*示例*

```text
pragma solidity ^0.4.0；
/** @title Shape calculator.*/
contract shapeCalculator{
    /**
    *@dev calculate a rectangle's suface and perimeter
    *@param w width of the rectangles
    *@param h height of the rectangles
    *@return s surface of the rectangles
    *@return p perimeter of the rectangles
    */

    function rectangles(uint w, uint h) returns (uint s, uint p){
        s = w * h;
        p = 2 * ( w + h) ;
    }
}
```

<a id="智能合约源文件基本要素概览"></a>

### 智能合约源文件基本要素概览（Structure of a Contract）

`Solidity` 合约和面向对象语言非常相似。每个合约均能包含状态变量`State Variables`, 函数`Functions`, 函数修饰符`Function Modifiers`, 事件`Events`, 结构体类型`Struct Types` 和 枚举类型`Enum Types`。除此以外，还有比较特殊的合约叫做库`libraries`和接口`interfaces`。

- 合约类似面向对象语言中的类。
- 支持继承

<a id="状态变量"></a>

#### 状态变量 State Variables

状态变量是其永远存储在合约实例中的变量。

```
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.0 <0.9.0;

contract SimpleStorage {
    uint storedData; // 状态变量
    // ...
}
```

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract Variables {
    // 状态变量存储在区块链上
    string public text = "Hello";
    uint public num = 123;

    function doSomething() public {
        // 局部变量不保存到区块链
        uint i = 456;

        // 全局变量
        uint timestamp = block.timestamp; // 当前块的时间戳
        address sender = msg.sender; // 来访者地址
    }
}
```

详情见`类型（Types）`章节，关于所有支持的类型和变量相关的可见性（Visibility and Accessors）。

<a id="函数"></a>

#### 函数 Functions

函数是合约实例对象的一种行为，可以通过合约实例调用函数请求其帮助我们完成我们期望的某个任务。

函数是代码的可执行单元。函数通常在合约内定义，但也可以在合约外定义。

```
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.0 <0.9.0;
contract SimpleAuction {
    function bid() public payable { // 函数、行为、方法
        // ...
    }
}

// Helper function defined outside of a contract
function helper(uint x) pure returns (uint) {
    return x * 2;
}
```

函数调用可以设置为内部（Internal）的和外部（External）的。同时对于其它合同的不同级别的可见性和访问控制(Visibility and Accessors)。具体的情况详见后面类型中关于函数的章节。

<a id="函数修饰符"></a>

#### 函数修饰符 Modifier

修改器（modifier）可以用来轻易的改变一个函数的行为，控制函数的逻辑，比如用于在函数执行前检查某种前置条件。

修改器是一种合约属性，可以被继承，同时还可被派生的合约重写（override）；

对于一个函数可以有多个修改器限制，在函数定义的时候依次写上，并用加空格分隔，执行的时候也是依次执行。多个修改器是同时限制，也就是说必须满足所有的修改器的权限，才可以执行函数体的代码；

```
modifier 函数修改器名(参数)｛
	a++;	// 代表函数前执行的代码
	_;		// 表示被修饰的函数中的代码
	a--;	// 代表函数后执行的代码
｝
```

函数修饰符可用于以声明方式修改功能的语义。Modifier修饰符不支持重载，也就是相同的名字不可能出现两个。

```
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.0 <0.9.0;
contract Purchase {
    address public seller;
    modifier onlySeller() { // Modifier修饰符
        require(
            msg.sender == seller,
            "Only seller can call this."
        );
    }
    
    // Modifier 使用场景，当调用`abort()`函数时，会先执行`onlySeller`检查是否满足条件，满足，继续执行，不满足，发生异常，停止
    function abort() public view onlySeller { 
        // ...
    }
}
```

<a id="事件"></a>

#### 事件 Events

事件是以太坊虚拟机(EVM)日志基础设施提供的一个便利接口。用于获取当前发生的事件。

```
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.0 <0.9.0;
contract SimpleAuction {
    event HighestBidIncreased(address bidder, uint amount); // Event
    function bid() public payable {
        // ...
        emit HighestBidIncreased(msg.sender, msg.value); // 触发 event
    }
}
```

<a id="错误"></a>

#### 错误 Error

错误允许您为故障情况定义描述性名称和数据。错误可用于还原语句。与字符串描述相比，错误要便宜得多，并且允许您对附加数据进行编码。您可以使用 NatSpec 向用户描述错误。

```
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;

/// Not enough funds for transfer. Requested `requested`,
/// but only `available` available.
error NotEnoughFunds(uint requested, uint available);

contract Token {
    mapping(address => uint) balances;
    function transfer(address to, uint amount) public {
        uint balance = balances[msg.sender];
        if (balance < amount)
            revert NotEnoughFunds(amount, balance);
        balances[msg.sender] -= amount;
        balances[to] += amount;
        // ...
    }
}
```

<a id="结构体"></a>

#### 结构体类型 Struct Types

结构是自定义的结构类型，可以对多个变量进行分组封装；

自定义的将几个变量组合在一起形成的类型。

```
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.0 <0.9.0;
contract Ballot {
    struct Voter { // Struct
        uint weight;
        bool voted;
        address delegate;
        uint vote;
    }
    
    struct manager{
        Voter employ;
        string title;
    }
}
```

<a id="枚举"></a>

#### 枚举 Enum Types

特殊的自定义类型，类型的所有值可枚举的情况。

```
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.0 <0.9.0;
contract Purchase {
    enum State { Created, Locked, Inactive } // Enum
}
```

<a id="映射"></a>

#### 映射-mapping

映射是一种引用类型，存储键--值对

格式：mapping(key=>value)

在mapping中，key可以是整型、字符串等基本数据类型，但不能使用动态数组、contract、枚举、struct、以及mapping这些类型；

value的类型没有限制；

mapping不能作为参数的形参使用

<a id="库"></a>

#### 库 library

```
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.0 <0.9.0;
struct Data {
    mapping(uint256 => bool) flags;
}

library Set {
    // 集合 Set library

    function insert(Data storage self, uint256 value) public returns (bool) {
        if (self.flags[value]) return false;
        self.flags[value] = true;
        return true;
    }

    function remove(Data storage self, uint256 value) public returns (bool) {
        if (!self.flags[value]) return false;
        self.flags[value] = false;
        return true;
    }

    function contains(Data storage self, uint256 value)
        public
        view
        returns (bool)
    {
        return self.flags[value];
    }
}

contract C {
    Data knownValues;

    function register(uint256 value) public {
        // library 函数不需要通过实例对象调用，可直接通过 library 名字直接调用
        require(Set.insert(knownValues, value));
    }
}

```

#### 接口 Interface

接口类似于抽象协议，但是不能实现任何功能。还有其他限制：

* 它们不能继承其他合约，但是可以从其他接口继承。
* 所有声明的函数都必须是外部的。
* 接口不能声明构造函数。
* 接口不能声明状态变量。

```
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.0 <0.9.0;
interface ParentA {
    function test() external returns (uint256);
}
interface ParentB {
    function test() external returns (uint256);
}

```

<a id="leixing"></a>

## 类型

由于Solidity是一个静态类型的语言，所以编译时需明确指定变量的类型（包括`本地变量`或`状态变量`），`Solidity`编程语言提供了一些`基本类型(elementary types)`可以用来组合成复杂类型。

Solidity 中不存在“未定义”或“空”值的概念，但新声明的变量始终具有取决于其类型的默认值。要处理任何意外值，您应该使用revert 函数来恢复整个事务，或者返回一个带有第二个bool值的元组，表示成功。

<a id="值类型"></a>

### 值类型 Value Type

以下类型也称为值类型，因为这些类型的变量总是按值传递，即当它们用作函数参数或赋值时，它们总是被复制。（为什么会叫`值类型`，是因为上述这些类型在传值时，总是值传递。比如在函数传参数时，或进行变量赋值时。）

<a id="布尔型"></a>

#### 布尔型 Booleans

bool: 可能的值是常数值`true`和`false`。

运算符：

- !（逻辑否定）
- &&（逻辑连接，“和”）
- ||（逻辑析取，“或”）
- ==（等于）
- !=（不等于）

备注：运算符`&&`和`||`是短路运算符，如`f(x)||g(y)`，当`f(x)`为真时，则不会继续执行`g(y)`。

<a id="整数"></a>

#### 整数 Integer

int / uint：各种大小的有符号和无符号不同位数的整型变量。关键字uint8 到 uint256（无符号 从8位 到 256 位 以及 int8 到 int256，以 `8` 位为步长递增。 `uint` 和 `int` 分别是 `uint256` 和 `int256` 的别名。

运算符：

- 比较运算符： `<=` ， `<` ， `==` ， `!=` ， `>=` ， `>` （返回布尔值）
- 位运算符： `&` ， `|` ， `^` （异或）， `~` （位取反）
- 移位运算符： `<<` （左移位） ， `>>` （右移位）
- 算数运算符： `+` ， `-` ， 一元运算负 `-` （仅针对有符号整型）， `*` ， `/` ， `%` （取余或叫模运算） ， `**` （幂）

对于整形 `X`，可以使用 `type(X).min` 和 `type(X).max` 去获取这个类型的最小值与最大值。

<a id="地址"></a>

#### 地址类型 Address

地址类型有两种形式，他们大致相同：

> - address：保存一个20字节的值（以太坊地址的大小）。
> - address payable ：可支付地址，与 `address` 相同，不过有成员函数 `transfer` 和 `send` 。

这种区别背后的思想是 address payable 可以接受以太币的地址，而一个普通的 address 则不能。

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract Payable {
    // 可支付地址可以接收以太币 Payable address can receive Ether
    address payable public owner;

    // 构造函数可支付接收以太币 Payable constructor can receive Ether
    constructor() payable {
        owner = payable(msg.sender);
    }

    // Function to deposit Ether into this contract.
    // Call this function along with some Ether.
    // The balance of this contract will be automatically updated.
    //将Ether存入此契约的函数。
	//调用此函数时同时调用一些Ether。
	//本合同余额将自动更新。
    function deposit() public payable {}

    // Call this function along with some Ether.
    // The function will throw an error since this function is not payable
    //调用此函数时同时调用一些Ether。
	//该函数将抛出一个错误，因为该函数是不可支付的。
    function notPayable() public {}

    // Function to withdraw all Ether from this contract.
    function withdraw() public {
        // get the amount of Ether stored in this contract
        uint amount = address(this).balance;

        // send all Ether to owner
        // Owner can receive Ether since the address of owner is payable
        (bool success, ) = owner.call{value: amount}("");
        require(success, "Failed to send Ether");
    }

    // Function to transfer Ether from this contract to address from input
    function transfer(address payable _to, uint _amount) public {
        // Note that "to" is declared as payable
        (bool success, ) = _to.call{value: _amount}("");
        require(success, "Failed to send Ether");
    }
}
```

##### 类型转换

允许从 address payable 到 address 的隐式转换，而从 address 到 address payable 的转换是不可以的（ 执行这种转换的唯一方法是使用中间类型，先转换为 uint160 ），如:

```
address payable ap = address(uint160(addr));
```

address 可以显式和整型、整型字面常量、bytes20 及合约类型相互转换。转换时需注意：不允许以 address payable(x) 形式转换。 如果 x 是整型或定长字节数组、字面常量或具有可支付的回退（ payable fallback ）函数的合约类型，则转换形式 address(x) 的结果是 address payable 类型。 如果 x 是没有可支付的回退（ payable fallback ）函数的合约类型，则 address(x) 将是 address类型。 在外部函数签名（定义）中，address 可用来表示 address 和 address payable 类型。

> 大部分情况下你不需要关心 address 与 address payable 之间的区别，并且到处都使用 address。 例如，如果你在使用  取款模式, 你可以（也应该）保存地址为 address 类型, 因为可以在msg.sender 对象上调用 transfer 函数, 因为 msg.sender 是 address payable。

###### address payable 转换为address

`address payable`类型的变量可以显式或隐式地转换为address类型：

```
address payable addr1 = msg.sender;
address addr2 = addr1; // 正确
address addr3 = address(addr1); // 正确
```

###### address转换为address payable

`address`类型的变量只能显式地转换为`address payable`，需要首先转换为整数类型（例如uint160），然后再将该整型值转换为address类型，就可以得到`address payable`：

```
address addr1 = msg.sender;
address payable addr2 = addr1; // 错误，address不能隐式地转换为address payable
address payable addr3 = address(uint160(addr1)); // 正确，先转换为uint160，然后转换为address payable
```

###### address[]或address payable[]的转换

虽然单个address payable变量可以转换为address类型，或者反之，但是不能直接将整个数组
进行转换。例如：

```
function testCast(address payable[] memory _addresses) returns (address[] memory)
{
    return _addresses; // 错误！
}
```

##### 运算符

`<=`，`<`，`==`，`!=`，`>=`和`>`

##### 地址类型成员变量

查看所有的成员，可参考 [地址成员](https://learnblockchain.cn/docs/solidity/units-and-global-variables.html#address-related)。

- `balance` 和 `transfer`

可以使用 `balance` 属性来查询一个地址的余额， 也可以使用 `transfer` 函数向一个可支付地址（payable address）发送 以太币Ether （以 wei 为单位）：

```
address x = 0x123;
address myAddress = this;
if (x.balance < 10 && myAddress.balance >= 10) x.transfer(10);
```

如果当前合约的余额不够多，则 `transfer` 函数会执行失败，或者如果以太转移被接收帐户拒绝， `transfer` 函数同样会失败而进行回退。

> 如果 x 是一个合约地址，它的代码（更具体来说是它的 Fallback 函数，如果有的话）会跟 transfer 函数调用一起执行（这是 EVM 的一个特性，无法阻止）。 如果在执行过程中用光了 gas 或者因为任何原因执行失败，以太币Ether 交易会被打回，当前的合约也会在终止的同时抛出异常。

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract addressTest {
	// 通过它能得到一个地址的余额。balance
    function getBalance(address addr) public view returns (uint){
        return addr.balance;
    }
}
```

this 如果只是想得到当前合约的余额，其实可以这样写

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract addressTest {
    function getBalance() public view returns (uint){
        return address(this).balance;
    }
}
```

- `send`

`send` 是 `transfer` 的低级版本。如果执行失败，当前的合约不会因为异常而终止，但 `send` 会返回 `false`。

> 在使用 send 的时候会有些风险：如果调用栈深度是 1024 会导致发送失败（这总是可以被调用者强制），如果接收者用光了 gas 也会导致发送失败。 所以为了保证 以太币Ether 发送的安全，一定要检查 send 的返回值，使用 transfer 或者更好的办法： 使用接收者自己取回资金的模式。

- `call`， `delegatecall` 和 `staticcall`

为了与不符合 应用二进制接口Application Binary Interface(ABI) 的合约交互，或者要更直接地控制编码，提供了函数 `call`，`delegatecall` 和 `staticcall` 。 它们都带有一个 `bytes memory` 参数和返回执行成功状态（`bool`）和数据（`bytes memory`）。

函数 `abi.encode`，`abi.encodePacked`，`abi.encodeWithSelector` 和 `abi.encodeWithSignature` 可用于编码结构化数据。

```
bytes memory payload = abi.encodeWithSignature("register(string)", "MyName");
(bool success, bytes memory returnData) = address(nameReg).call(payload);
require(success);
```

此外，为了与不符合 应用二进制接口Application Binary Interface(ABI) 的合约交互，于是就有了可以接受任意类型任意数量参数的 `call` 函数。 这些参数会被打包到以 32 字节为单位的连续区域中存放。 其中一个例外是当第一个参数被编码成正好 4 个字节的情况。 在这种情况下，这个参数后边不会填充后续参数编码，以允许使用函数签名。

```
address nameReg = 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2;
nameReg.call("register", "MyName");
nameReg.call(bytes4(keccak256("fun(uint256)")), a);
```

> 所有这些函数都是低级函数，应谨慎使用。 具体来说，任何未知的合约都可能是恶意的，我们在调用一个合约的同时就将控制权交给了它，而合约又可以回调合约，所以要准备好在调用返回时改变相应的状态变量（可参考  可重入 )， 与其他合约交互的常规方法是在合约对象上调用函数（x.f()）。

可以使用 `gas` 修改器modifier 调整提供的 gas 数量：

```
address(nameReg).call{gas: 1000000}(abi.encodeWithSignature("register(string)", "MyName"));
```

类似地，也能控制提供的 以太币Ether 的值：

```
address(nameReg).call{value: 1 ether}(abi.encodeWithSignature("register(string)", "MyName"));
```

最后一点，这些 修改器modifier 可以联合使用。每个修改器出现的顺序不重要：

```
address(nameReg).call{gas: 1000000, value: 1 ether}(abi.encodeWithSignature("register(string)", "MyName"));
```

以类似的方式，可以使用函数 `delegatecall` ：区别在于只调用给定地址的代码（函数），其他状态属性如（存储，余额 …）都来自当前合约。 `delegatecall` 的目的是使用另一个合约中的库代码。 用户必须确保两个合约中的存储结构都适合委托调用 （delegatecall）。

从以太坊拜占庭（byzantium）版本开始 提供了 `staticcall` ，它与 `call` 基本相同，但如果被调用的函数以任何方式修改状态变量，都将回退。

所有三个函数 `call` ， `delegatecall` 和 `staticcall` 都是非常低级的函数，应该只把它们当作 *最后一招* 来使用，因为它们破坏了 Solidity 的类型安全性。

所有三种方法都提供 `gas` 选项，而 `value` 选项仅 `call` 支持 。

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract Primitives {
    bool public boo = true;

    /*
    Uint代表无符号整数，即非负整数
	不同尺寸可选
        uint8   ranges from 0 to 2 ** 8 - 1
        uint16  ranges from 0 to 2 ** 16 - 1
        ...
        uint256 ranges from 0 to 2 ** 256 - 1
    */
    uint8 public u8 = 1;
    uint public u256 = 456;
    uint public u = 123; // Uint是uint256的别名

    /*
    整数类型允许为负数。
	与uint一样，从int8到int256可以使用不同的范围
    int256 ranges from -2 ** 255 to 2 ** 255 - 1
    int128 ranges from -2 ** 127 to 2 ** 127 - 1
    */
    int8 public i8 = -1;
    int public i256 = 456;
    int public i = -123; // int is same as int256

    // int的最小值和最大值
    int public minInt = type(int).min;
    int public maxInt = type(int).max;

    address public addr = 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c;

    /*
    在Solidity中，数据类型byte表示一个字节序列。
	solidity提供了两种类型的字节:
        -固定大小的字节数组
        -动态大小的字节数组。
	Solidity中的字节表示一个动态字节数组。
	它是byte[]的简写。
    */
    bytes1 a = 0xb5; //  [10110101]
    bytes1 b = 0x56; //  [01010110]

    // Default values
    // 未赋值的变量有一个默认值
    bool public defaultBoo; // false
    uint public defaultUint; // 0
    int public defaultInt; // 0
    address public defaultAddr; // 0x0000000000000000000000000000000000000000
}
```

> 所有合约都可以转换为 address 类型，因此可以使用 address(this).balance 查询当前合约的余额

<a id="字节数组"></a>

#### 字节数组 byte arrays

##### 定长字节数组 Fixed-size byte arrays

`bytes1`， ... ，`bytes32`，允许值以步长`1`递增。`byte`默认表示`byte1`。

###### 运算符

比较：`<=`，`<`，`==`，`!=`，`>=`，`>`，返回值为`bool`类型。

位运算符：`&`，`|`，`^`(异或)，`~`非

支持序号的访问，与大多数语言一样，取值范围[0, n)，其中`n`表示长度。

###### 成员变量

`.length`表示这个字节数组的长度（只读）。

##### 动态大小的字节数组

`bytes`： 动态长度的字节数组，参见[数组(Arrays)](https://solidity.tryblockchain.org/Solidity-Array-数组.html)。非值类型[1](https://solidity.tryblockchain.org/Solidity-Type-ByteArrays-字节数组.html#fn1)。

`string`： 动态长度的UTF-8编码的字符类型，参见[数组(Arrays)](https://solidity.tryblockchain.org/Solidity-Array-数组.html)。非值类型[valueType]。

一个好的使用原则是:

- `bytes`用来存储任意长度的字节数据，`string`用来存储任意长度的`UTF-8`编码的字符串数据。
- 如果长度可以确定，尽量使用定长的如`byte1`到`byte32`中的一个，因为这样更省空间。

<a id="小数"></a>

#### 小数

文档上称，暂不支持

<a id="字符串"></a>

#### 字符串 String literal

##### 字符串字面量

字符串字面量是指由单引号，或双引号引起来的字符串。字符串并不像C语言，包含结束符，`foo`这个字符串大小仅为三个字节。

##### 定长字节数组

正如整数一样，字符串的长度类型可以是变长的。特殊之处在于，可以隐式的转换为`byte1`,...`byte32`。下面来看看这个特性：

```text
pragma solidity ^0.4.0;

contract StringConvert{
    function test() returns (bytes3){
      bytes3 a = "123";

      //bytes3 b = "1234";
      //Error: Type literal_string "1234" is not implicitly convertible to expected type bytes3.

      return a;
  }
}
```

上述的字符串字面量，会隐式转换为`bytes3`。但这样不是理解成`bytes3`的字面量方式一个意思。

##### 转义字符

字符串字面量支持转义字符，比如`\n`，`\xNN`，`\uNNNN`。其中`\xNN`表式16进制值，最终录入合适的字节。而`\uNNNN`表示`Unicode`码点值，最终会转换为`UTF8`的序列。

<a id="枚举"></a>

#### 枚举

枚举类型是在Solidity中的一种用户自定义类型。他可以显示的转换与整数进行转换，但不能进行隐式转换。显示的转换会在运行时检查数值范围，如果不匹配，将会引起异常。枚举类型应至少有一名成员。我们来看看下面的例子吧。

使用 `type(NameOfEnum).min` 和 `type(NameOfEnum).max` 你可以得到给定枚举的最小值和最大值。

```
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.8;

contract test {
    enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }
    ActionChoices choice;
    ActionChoices constant defaultChoice = ActionChoices.GoStraight;

    function setGoStraight() public {
        choice = ActionChoices.GoStraight;
    }

    // 由于枚举类型不属于 |ABI| 的一部分，因此对于所有来自 Solidity 外部的调用，
    // "getChoice" 的签名会自动被改成 "getChoice() returns (uint8)"。

    function getChoice() public view returns (ActionChoices) {
        return choice;
    }

    function getDefaultChoice() public pure returns (uint) {
        return uint(defaultChoice);
    }

    function getLargestValue() public pure returns (ActionChoices) {
        return type(ActionChoices).max;
    }

    function getSmallestValue() public pure returns (ActionChoices) {
        return type(ActionChoices).min;
    }
}
```

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract Enum {
    // Enum representing shipping status
    enum Status {
        Pending,
        Shipped,
        Accepted,
        Rejected,
        Canceled
    }
    
    // 默认值为 类型的定义，在本例中为"Pending"
    Status public status;

    // Returns uint
    // Pending  - 0
    // Shipped  - 1
    // Accepted - 2
    // Rejected - 3
    // Canceled - 4
    function get() public view returns (Status) {
        return status;
    }

    // 通过将uint传入input来更新状态
    function set(Status _status) public {
        status = _status;
    }

    // 您可以像这样更新到特定的枚举
    function cancel() public {
        status = Status.Accepted;
    }

    // delete resets the enum to its first value, 0
    function reset() public {
        delete status;
    }
}
```

<a id="函数类型"></a>

#### 函数类型 function Types

函数类型即是函数这种特殊的类型。

- 可以将一个函数赋值给一个变量，一个函数类型的变量。
- 还可以将一个函数作为参数进行传递。
- 也可以在函数调用中返回一个函数。

函数类型有两类;可分为`internal`和`external`函数。

##### 内部函数(internal)

因为不能在当前合约的上下文环境以外的地方执行，内部函数只能在当前合约内被使用。如在当前的代码块内，包括内部库函数，和继承的函数中。

##### 外部函数（External）

外部函数由地址和函数方法签名两部分组成。可作为`外部函数调用`的参数，或者由`外部函数调用`返回。

##### 函数的定义

完整的函数的定义如下:

```text
function (<parameter types>) {internal|external} [pure|constant|view|payable] [returns (<return types>)]
```

与参数类型相反，返回类型不能为空 —— 如果函数类型不需要返回，则需要删除整个 `returns (<return types>)` 部分。

函数类型默认是内部函数，因此不需要声明 `internal`关键字。

##### 类型转换

函数类型 `A` 可以隐式转换为函数类型 `B` 当且仅当: 它们的参数类型相同，返回类型相同，它们的内部/外部属性是相同的，并且 `A` 的状态可变性比 `B` 的状态可变性更具限制性，比如：

- `pure` 函数可以转换为 `view` 和 `non-payable` 函数
- `view` 函数可以转换为 `non-payable` 函数
- `payable` 函数可以转换为 `non-payable` 函数

其他的转换则不可以。

关于 `payable` 和 `non-payable` 的规则可能有点令人困惑，但实质上，如果一个函数是 `payable` ，这意味着它 也接受零以太的支付，因此它也是 `non-payable` 。 另一方面，`non-payable` 函数将拒绝发送给它的 以太币Ether ， 所以 `non-payable` 函数不能转换为 `payable` 函数。

如果当函数类型的变量还没有初始化时就调用它的话会引发一个 [Panic 异常](https://learnblockchain.cn/docs/solidity/control-structures.html#assert-and-require)。 如果在一个函数被 `delete` 之后调用它也会发生相同的情况。

如果外部函数类型在 Solidity 的上下文环境以外的地方使用，它们会被视为 `function` 类型。 该类型将函数地址紧跟其函数标识一起编码为一个 `bytes24` 类型。。

>  请注意，当前合约的 public 函数既可以被当作内部函数也可以被当作外部函数使用。 如果想将一个函数当作内部函数使用，就用 `f` 调用，如果想将其当作外部函数，使用 `this.f` 。

```
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.4.16  <0.9.0;

library ArrayUtils {
  // 内部函数可以在内部库函数中使用，
  // 因为它们会成为同一代码上下文的一部分
  function map(uint[] memory self, function (uint) pure returns (uint) f)
    internal
    pure
    returns (uint[] memory r)
  {
    r = new uint[](self.length);
    for (uint i = 0; i < self.length; i++) {
      r[i] = f(self[i]);
    }
  }
  function reduce(
    uint[] memory self,
    function (uint, uint) pure returns (uint) f
  )
    internal
    pure
    returns (uint r)
  {
    r = self[0];
    for (uint i = 1; i < self.length; i++) {
      r = f(r, self[i]);
    }
  }
  function range(uint length) internal pure returns (uint[] memory r) {
    r = new uint[](length);
    for (uint i = 0; i < r.length; i++) {
      r[i] = i;
    }
  }
}

contract Pyramid {
  using ArrayUtils for *;
  function pyramid(uint l) public pure returns (uint) {
    return ArrayUtils.range(l).map(square).reduce(sum);
  }
  function square(uint x) internal pure returns (uint) {
    return x * x;
  }
  function sum(uint x, uint y) internal pure returns (uint) {
    return x + y;
  }
}
```

```
pragma solidity >=0.4.22  <0.9.0;

contract Oracle {
  struct Request {
    bytes data;
    function(uint) external callback;
  }
  Request[] private requests;
  event NewRequest(uint);
  function query(bytes memory data, function(uint) external callback) public {
    requests.push(Request(data, callback));
    emit NewRequest(requests.length - 1);
  }
  function reply(uint requestID, uint response) public {
    // 这里检查回复来自可信来源
    requests[requestID].callback(response);
  }
}

contract OracleUser {
  Oracle constant private ORACLE_CONST = Oracle(address(0x00000000219ab540356cBB839Cbe05303d7705Fa)); // known contract
  uint private exchangeRate;
  function buySomething() public {
    ORACLE_CONST.query("USD", this.oracleResponse);
  }
  function oracleResponse(uint response) public {
    require(
        msg.sender == address(ORACLE_CONST),
        "Only oracle can call this."
    );
    exchangeRate = response;
  }
}
```

<a id="引用类型"></a>

### 引用类型 Reference Type

复杂类型。不同于之前值类型，复杂类型占的空间更大，超过256字节，因为拷贝它们占用更多的空间。由此我们需要考虑将它们存储在什么位置`内存（memory，数据不是永久存在的）`或`存储(storage，值类型中的状态变量)`

<a id="数据位置"></a>

#### 数据位置 Data location

复杂类型，如`数组(arrays)`和`数据结构(struct)`在Solidity中有一个额外的属性，数据的存储位置。可选为`memory`和`storage`。

`memory`存储位置同我们普通程序的内存一致。即分配，即使用，越过作用域即不可被访问，等待被回收。而在区块链上，由于底层实现了图灵完备，故而会有非常多的状态需要永久记录下来。比如，参与众筹的所有参与者。那么我们就要使用`storage`这种类型了，一旦使用这个类型，数据将永远存在。

基于程序的上下文，大多数时候这样的选择是默认的，我们可以通过指定关键字`storage`和`memory`修改它。

默认的函数参数，包括返回的参数，他们是`memory`。默认的局部变量是`storage`的[1](https://solidity.tryblockchain.org/Solidity-DataLocation-数据位置.html#fn1)。而默认的状态变量（合约声明的公有变量）是`storage`。

另外还有第三个存储位置`calldata`。它存储的是函数参数，是只读的，不会永久存储的一个数据位置。`外部函数`的参数（不包括返回参数）被强制指定为`calldata`。效果与`memory`差不多。

数据位置指定非常重要，因为不同数据位置变量赋值产生的结果也不同。在`memory`和`storage`之间，以及它们和`状态变量`（即便从另一个状态变量）中相互赋值，总是会创建一个完全不相关的拷贝。

将一个`storage`的状态变量，赋值给一个`storage`的局部变量，是通过引用传递。所以对于局部变量的修改，同时修改关联的状态变量。但另一方面，将一个`memory`的引用类型赋值给另一个`memory`的引用，不会创建另一个拷贝。

```
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.5.0 <0.9.0;

contract Tiny {
    uint[] x; // x 的数据存储位置是 storage，　位置可以忽略

    // memoryArray 的数据存储位置是 memory
    function f(uint[] memory memoryArray) public {
        x = memoryArray; // 将整个数组拷贝到 storage 中，可行
        uint[] storage y = x;  // 分配一个指针（其中 y 的数据存储位置是 storage），可行
        y[7]; // 返回第 8 个元素，可行
        y.pop(); // 通过 y 修改 x，可行
        delete x; // 清除数组，同时修改 y，可行

        // 下面的就不可行了；需要在 storage 中创建新的未命名的临时数组，
        // 但 storage 是“静态”分配的：
        // y = memoryArray;
        // 下面这一行也不可行，因为这会“重置”指针，
        // 但并没有可以让它指向的合适的存储位置。
        // delete y;

        g(x); // 调用 g 函数，同时移交对 x 的引用
        h(x); // 调用 h 函数，同时在 memory 中创建一个独立的临时拷贝
    }

    function g(uint[] storage ) internal pure {}
    function h(uint[] memory) public pure {}
}
```

##### 强制的数据位置(Forced data location)

- `外部函数(External function)`的参数(不包括返回参数)强制为：`calldata`
- `状态变量(State variables)`强制为: `storage`

##### 默认数据位置（Default data location）

- 函数参数（括返回参数：`memory`
- 所有其它的局部变量：`storage`

<a id="数组"></a>

#### 数组

数组可以在声明时指定长度，也可以动态调整大小（长度）。

一个元素类型为 `T`，固定长度为 `k` 的数组可以声明为 `T[k]`，而动态数组声明为 `T[]`。 举个例子，一个长度为 5，元素类型为 `uint` 的动态数组的数组（二维数组），应声明为 `uint[][5]` （注意这里跟其它语言在Solidity中， `X[3]` 总是一个包含三个 `X` 类型元素的数组，即使 `X` 本身就是一个数组，这和其他语言也有所不同，比如 C 语言。

在Solidity中， `X[3]` 总是一个包含三个 `X` 类型元素的数组，即使 `X` 本身就是一个数组，这和其他语言也有所不同，比如 C 语言。

数组下标是从 0 开始的，且访问数组时的下标顺序与声明时相反。

如：如果有一个变量为 `uint[][5] memory x`， 要访问第三个动态数组的第7个元素，使用 x[2] [6]，要访问第三个动态数组使用 `x[2]`。 同样，如果有一个 `T` 类型的数组 `T[5] a` ， T 也可以是一个数组，那么 `a[2]` 总会是 `T` 类型。

数组元素可以是任何类型，包括映射或结构体。对类型的限制是映射只能存储在 存储storage 中，并且公开访问函数的参数需要是 ABI 类型。

状态变量标记 `public` 的数组，Solidity创建一个 getter函数 。 小标数字索引就是 getter函数 的参数。

访问超出数组长度的元素会导致异常（assert 类型异常 ）。 可以使用 `.push()` 方法在末尾追加一个新元素，其中 `.push()` 追加一个零初始化的元素并返回对它的引用。

##### `bytes` 和 `string` 也是数组

`bytes` 和 `string` 类型的变量是特殊的数组。 `bytes` 类似于 `bytes1[]`，但它在 调用数据calldata 和 内存memory 中会被“紧打包”（译者注：将元素连续地存在一起，不会按每 32 字节一单元的方式来存放）。 `string` 与 `bytes` 相同，但不允许用长度或索引来访问。

Solidity没有字符串操作函数，但是可以使用第三方字符串库，我们可以比较两个字符串通过计算他们的 keccak256-hash ，可使用 `keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))` 和使用 `string.concat(s1, s2)` 来拼接字符串。

我们更多时候应该使用 `bytes` 而不是 `bytes1[]` ，因为Gas 费用更低, 在内存memory 中使用 `bytes1[]` 时，会在元素之间添加31个填充字节。 而在存储storage 中，由于紧密包装，这没有填充字节， 参考 [bytes and string](https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html#bytes-and-string) 。 作为一个基本规则，对任意长度的原始字节数据使用 `bytes`，对任意长度字符串（UTF-8）数据使用 `string` 。

如果使用一个长度限制的字节数组，应该使用一个 `bytes1` 到 `bytes32` 的具体类型，因为它们便宜得多。

> 如果想要访问以字节表示的字符串 `s`，请使用 `bytes(s).length` / `bytes(s)[7] = 'x';`。 注意这时你访问的是 UTF-8 形式的低级 bytes 类型，而不是单个的字符。

##### 函数 `bytes.concat` 和 `string.concat`

可以使用 `string.concat` 连接任意数量的 `string` 字符串。 该函数返回一个 `string memory` ，包含所有参数的内容，无填充方式拼接在一起。 如果你想使用不能隐式转换为 `string` 的其他类型作为参数，你需要先把它们转换为 `string`。

同样， `bytes.concat` 函数可以连接任意数量的 `bytes` 或 `bytes1 ... bytes32` 值。 该函数返回一个 `bytes memory` ，包含所有参数的内容，无填充方式拼接在一起。 如果你想使用字符串参数或其他不能隐式转换为 `bytes` 的类型，你需要先将它们转换为 `bytes``或 ``bytes1`/…/ `bytes32`。

```
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.12;

contract C {
    string s = "Storage";
    function f(bytes calldata bc, string memory sm, bytes16 b) public view {
        string memory concatString = string.concat(s, string(bc), "Literal", sm);
        assert((bytes(s).length + bc.length + 7 + bytes(sm).length) == bytes(concatString).length);

        bytes memory concatBytes = bytes.concat(bytes(s), bc, bc[:2], "Literal", bytes(sm), b);
        assert((bytes(s).length + bc.length + 2 + 7 + bytes(sm).length + b.length) == concatBytes.length);
    }
}
```

如果你调用不使用参数调用 `string.concat` 或 `bytes.concat` 将返回空数组。

##### 创建内存数组

可使用 `new` 关键字在 内存memory 中基于运行时创建动态长度数组。 与存储storage 数组相反的是，你不能通过修改成员变量 `.push` 改变 内存memory 数组的大小。

必须提前计算所需的大小或者创建一个新的内存数组并复制每个元素。

在Solidity中的所有变量，新分配的数组元素总是以 [默认值](https://learnblockchain.cn/docs/solidity/control-structures.html#default-value) 初始化。

```
pragma solidity >=0.4.16 <0.9.0;

contract TX {
    function f(uint len) public pure {
        uint[] memory a = new uint[](7);
        bytes memory b = new bytes(len);

        assert(a.length == 7);
        assert(b.length == len);

        a[6] = 8;
    }
}
```

```
pragma solidity ^0.4.0;

contract C {
    function f() {
        //创建一个memory的数组
        uint[] memory a = new uint[](7);
        
        //不能修改长度
        //Error: Expression has to be an lvalue.
        //a.length = 100;
    }
    
    //storage
    uint[] b;
    
    function g(){
        b = new uint[](7);
        //可以修改storage的数组
        b.length = 10;
        b[9] = 100;
    }
}
```

##### 数组常量

数组常量（字面量）是在方括号中（ `[...]` ） 包含一个或多个逗号分隔的表达式。例如 `[1, a, f(3)]` 。

数组常量的类型通过以下的方式确定:

它总是一个静态大小的内存数组，其长度为表达式的数量。

数组的基本类型是列表上的第一个表达式的类型，以便所有其他表达式可以隐式地转换为它。如果不可以转换，将出现类型错误。

所有元素都都可以转换为基本类型也是不够的。其中一个元素必须是这种类型的。

在下面的例子中， `[1, 2, 3]` 的类型是 `uint8[3] memory`。 因为每个常量的类型都是 `uint8` ，如果你希望结果是 `uint[3] memory` 类型，你需要将第一个元素转换为 `uint` 。

```
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.4.16 <0.9.0;

contract LBC {
    function f() public pure {
        g([uint(1), 2, 3]);
    }
    function g(uint[3] memory) public pure {
        // ...
    }
}
```

数组常量 `[1, -1]` 是无效的，因为第一个表达式类型是 `uint8` 而第二个类似是 `int8` 他们不可以隐式的相互转换。 为了确保可以运行，你是可以使用例如： `[int8(1), -1]` 。

由于不同类型的固定大小的内存数组不能相互转换(尽管基础类型可以)，如果你想使用二维数组常量，你必须显式地指定一个基础类型:

```
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.4.16 <0.9.0;

contract C {
    function f() public pure returns (uint24[2][4] memory) {
        uint24[2][4] memory x = [[uint24(0x1), 1], [0xffffff, 2], [uint24(0xff), 3], [uint24(0xffff), 4]];
        // 下面代码无法工作，因为没有匹配内部类型
        // uint[2][4] memory x = [[0x1, 1], [0xffffff, 2], [0xff, 3], [0xffff, 4]];
        return x;
    }
}
```

目前需要注意的是，定长的 内存memory 数组并不能赋值给变长的 内存memory 数组，下面的例子是无法运行的：

```
pragma solidity  >=0.4.0 <0.9.0;

// 这段代码并不能编译。
contract LBC {
    function f() public {
        // 这一行引发了一个类型错误，因为 unint[3] memory
        // 不能转换成 uint[] memory。
        uint[] x = [uint(1), 3, 4];
    }
}
```

计划在未来移除这样的限制，但目前数组在 ABI 中传递的问题造成了一些麻烦。

如果要初始化动态长度的数组，则必须显示给各个元素赋值:

```
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.4.0 <0.9.0;

contract C {
    function f() public pure {
        uint[] memory x = new uint[](3);
        x[0] = 1;
        x[1] = 3;
        x[2] = 4;
    }
}
```

##### 数组成员

**length**:

数组有 `length` 成员变量表示当前数组的长度。 一经创建，内存memory 数组的大小就是固定的（但却是动态的，也就是说，它可以根据运行时的参数创建）。

**push()**:

动态的 存储storage 数组以及 `bytes` 类型（ `string` 类型不可以）都有一个 `push()` 的成员函数，它用来添加新的零初始化元素到数组末尾，并返回元素引用． 因此可以这样：　 `x.push().t = 2` 或 `x.push() = b`.

**push(x)**:

动态的 存储storage 数组以及 `bytes` 类型（ `string` 类型不可以）都有一个 `push(ｘ)` 的成员函数，用来在数组末尾添加一个给定的元素，这个函数没有返回值．

**pop()**:

变长的 存储storage 数组以及 `bytes` 类型（ `string` 类型不可以）都有一个 `pop()` 的成员函数， 它用来从数组末尾删除元素。 同样的会在移除的元素上隐含调用 delete。

> 通过 `push()`　增加 存储storage 数组的长度具有固定的 gas 消耗，因为 存储storage 总是被零初始化，而通过　`pop()`　减少长度则依赖移除与元素的大小（size）．　如果元素是数组,则成本是很高的,因为它包括已删除的元素的清理，类似于在这些元素上调用 [delete](https://learnblockchain.cn/docs/solidity/types.html#delete) 。

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract Array {
    // Several ways to initialize an array
    uint[] public arr;
    uint[] public arr2 = [1, 2, 3];
    // 固定大小的数组，所有元素初始化为0
    uint[10] public myFixedSizeArr;

    function get(uint i) public view returns (uint) {
        return arr[i];
    }

    // Solidity可以返回整个数组。
    // 但是这个函数应该避免
    // 数组的长度可以无限增长。
    function getArr() public view returns (uint[] memory) {
        return arr;
    }

    function push(uint i) public {
        // 添加到数组
        // 这将使数组长度增加1。
        arr.push(i);
    }

    function pop() public {
        // 从数组中删除最后一个元素
        // 这将使数组长度减少1
        arr.pop();
    }

    function getLength() public view returns (uint) {
        return arr.length;
    }

    function remove(uint index) public {
        // Delete不改变数组长度。
        // 将index的值重置为默认值，
        // 在本例中为0
        delete arr[index];
    }

    function examples() external {
        // 在内存中创建数组，只能创建固定大小的数组
        uint[] memory a = new uint[](5);
    }
}
```

通过从右向左移动元素来删除数组元素

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract ArrayRemoveByShifting {
    // [1, 2, 3] -- remove(1) --> [1, 3, 3] --> [1, 3]
    // [1, 2, 3, 4, 5, 6] -- remove(2) --> [1, 2, 4, 5, 6, 6] --> [1, 2, 4, 5, 6]
    // [1, 2, 3, 4, 5, 6] -- remove(0) --> [2, 3, 4, 5, 6, 6] --> [2, 3, 4, 5, 6]
    // [1] -- remove(0) --> [1] --> []

    uint[] public arr;

    function remove(uint _index) public {
        require(_index < arr.length, "index out of bound");

        for (uint i = _index; i < arr.length - 1; i++) {
            arr[i] = arr[i + 1];
        }
        arr.pop();
    }

    function test() external {
        arr = [1, 2, 3, 4, 5];
        remove(2);
        // [1, 2, 4, 5]
        assert(arr[0] == 1);
        assert(arr[1] == 2);
        assert(arr[2] == 4);
        assert(arr[3] == 5);
        assert(arr.length == 4);

        arr = [1];
        remove(0);
        // []
        assert(arr.length == 0);
    }
}
```

通过将最后一个元素复制到要删除的位置来删除数组元素

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract ArrayReplaceFromEnd {
    uint[] public arr;

    // 删除一个元素会在数组中产生一个空白。
    // 保持数组紧凑的一个技巧是
    // 移动最后一个元素到要删除的位置。
    function remove(uint index) public {
        // 将最后一个元素移到要删除的位置
        arr[index] = arr[arr.length - 1];
        // Remove the last element
        arr.pop();
    }

    function test() public {
        arr = [1, 2, 3, 4];

        remove(1);
        // [1, 4, 3]
        assert(arr.length == 3);
        assert(arr[0] == 1);
        assert(arr[1] == 4);
        assert(arr[2] == 3);

        remove(2);
        // [1, 4]
        assert(arr.length == 2);
        assert(arr[0] == 1);
        assert(arr[1] == 4);
    }
}
```

<a id="结构体"></a>

#### 结构体 struct

`Solidity`提供`struct`来定义自定义类型。我们来看看下面的例子：

```
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.6.0 <0.9.0;

// 定义的新类型包含两个属性。
// 在合约外部声明结构体可以使其被多个合约共享。 在这里，这并不是真正需要的。
struct Funder {
    address addr;
    uint amount;
}

contract CrowdFunding {
    // 也可以在合约内部定义结构体，这使得它们仅在此合约和衍生合约中可见。
    struct Campaign {
        address beneficiary;
        uint fundingGoal;
        uint numFunders;
        uint amount;
        mapping (uint => Funder) funders;
    }

    uint numCampaigns;
    mapping (uint => Campaign) campaigns;

    function newCampaign(address payable beneficiary, uint goal) public returns (uint campaignID) {
        campaignID = numCampaigns++; // campaignID 作为一个变量返回

        // 不能使用 "campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0)"
        // 因为RHS（right hand side）会创建一个包含映射的内存结构体 "Campaign"
        Campaign storage c = campaigns[campaignID];
        c.beneficiary = beneficiary;
        c.fundingGoal = goal;
    }

    function contribute(uint campaignID) public payable {
        Campaign storage c = campaigns[campaignID];
        // 以给定的值初始化，创建一个新的临时 memory 结构体，
        // 并将其拷贝到 storage 中。
        // 注意你也可以使用 Funder(msg.sender, msg.value) 来初始化。
        c.funders[c.numFunders++] = Funder({addr: msg.sender, amount: msg.value});
        c.amount += msg.value;
    }

    function checkGoalReached(uint campaignID) public returns (bool reached) {
        Campaign storage c = campaigns[campaignID];
        if (c.amount < c.fundingGoal)
            return false;
        uint amount = c.amount;
        c.amount = 0;
        c.beneficiary.transfer(amount);
        return true;
    }
}
```

上面的合约只是一个简化版的 [众筹合约](https://learnblockchain.cn/2018/02/28/ico-crowdsale/)，但它已经足以让我们理解结构体的基础概念。 结构体类型可以作为元素用在映射和数组中，其自身也可以包含映射和数组作为成员变量。

尽管结构体本身可以作为映射的值类型成员，但它并不能包含自身。 这个限制是有必要的，因为结构体的大小必须是有限的。

注意在函数中使用结构体时，一个结构体是如何赋值给一个存储位置是 存储storage 的局部变量。 在这个过程中并没有拷贝这个结构体，而是保存一个引用，所以对局部变量成员的赋值实际上会被写入状态。

当然，你也可以直接访问结构体的成员而不用将其赋值给一个局部变量，就像这样， `campaigns[campaignID].amount = 0`。

<a id="映射"></a>

### 映射/字典 mappings

`映射`或字典类型，一种键值对的映射关系存储结构。定义方式为`mapping(_KeyType => _KeyValue)`。键的类型允许除`映射`外的所有类型，如数组，合约，枚举，结构体。值的类型无限制。

`映射`可以被视作为一个哈希表，其中所有可能的键已被虚拟化的创建，被映射到一个默认值（二进制表示的零）。但在映射表中，我们并不存储键的数据，仅仅存储它的`keccak256`哈希值，用来查找值时使用。

因此，`映射`并没有长度，键集合（或列表），值集合（或列表）这样的概念。

`映射`类型，仅能用来定义`状态变量`，或者是在内部函数中作为`storage`类型的引用。引用是指你可以声明一个，如`var storage mappVal`的用于存储状态变量的引用的对象，但你没办法使用非状态变量来初始化这个引用。

可以通过将`映射`标记为`public`，来让Solidity创建一个访问器。要想访问这样的`映射`，需要提供一个键值做为参数。如果`映射`的值类型也是`映射`，使用访问器访问时，要提供这个`映射`值所对应的键，不断重复这个过程。下面来看一个例子：

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract Mapping {
    // Mapping from address to uint
    mapping(address => uint) public myMap;

    function get(address _addr) public view returns (uint) {
        // Mapping always returns a value.
        // If the value was never set, it will return the default value.
        return myMap[_addr];
    }

    function set(address _addr, uint _i) public {
        // Update the value at this address
        myMap[_addr] = _i;
    }

    function remove(address _addr) public {
        // Reset the value to the default value.
        delete myMap[_addr];
    }
}

contract NestedMapping {
    // Nested mapping (mapping from address to another mapping)
    mapping(address => mapping(uint => bool)) public nested;

    function get(address _addr1, uint _i) public view returns (bool) {
        // You can get values from a nested mapping
        // even when it is not initialized
        return nested[_addr1][_i];
    }

    function set(
        address _addr1,
        uint _i,
        bool _boo
    ) public {
        nested[_addr1][_i] = _boo;
    }

    function remove(address _addr1, uint _i) public {
        delete nested[_addr1][_i];
    }
}
```

<a id="基本类型之间的转换"></a>

### 基本类型之间的转换

#### 隐式转换

如果一个运算符用在两个不同类型的变量之间，那么编译器将隐式地将其中一个类型转换为另一个类型（不同类型之间的赋值也是一样）。 一般来说，只要值类型之间的转换在语义上行得通，而且转换的过程中没有信息丢失，那么隐式转换基本都是可以实现的： `uint8` 可以转换成 `uint16`，`int128` 转换成 `int256`，但 `int8` 不能转换成 `uint256` （因为 `uint256` 不能涵盖某些值，例如，`-1`）。 更进一步来说，无符号整型可以转换成跟它大小相等或更大的字节类型，但反之不能。 任何可以转换成 `uint160` 的类型都可以转换成 `address` 类型。

#### 显式转换

如果某些情况下编译器不支持隐式转换，但是你很清楚你要做什么，这种情况可以考虑显式转换。 注意这可能会发生一些无法预料的后果，因此一定要进行测试，确保结果是你想要的！ 下面的示例是将一个 `int8` 类型的负数转换成 `uint`：

```
int8 y = -3;
uint x = uint(y);
```

这段代码的最后，`x` 的值将是 `0xfffff..fd` （64 个 16 进制字符），因为这是 -3 的 256 位补码形式。

如果一个类型显式转换成更小的类型，相应的高位将被舍弃

```
uint32 a = 0x12345678;
uint16 b = uint16(a); // 此时 b 的值是 0x5678
```

<a id="单位和全局变量"></a>

## 单位和全局变量

Solidity中有两个单位：货币单位和时间单位

<a id="货币单位"></a>

### 货币单位（Ether Uint）

* 以太坊的货币单位称为以太，也称为ETH；
* ether被细分为更小的单位，直到可能的最小单位wei；
* 一个数字常量后面跟随一个后缀wei，ether，这个后缀就是货币单位。不同的单位可以转换，不含任何后缀的默认单位是wei

<a id="时间单位"></a>

### 时间单位（Time Uint）

时间单位seconds、minutes、hours、days、weeks、years均可作为后缀，并进行相互转换，规则如下：

- 1 == 1 seconds
- 1 minutes == 60 seconds
- 1 hours  == 60 minutes 
- 1 days  == 24 hours
- 1 weeks == 7 days  

这些后缀不能直接用在变量后边。如果想用时间单位（例如 days）来将输入变量换算为时间，你可以用如下方式来完成:

```
function f(uint start, uint daysAfter) public {
    if (block.timestamp >= start + daysAfter * 1 days) {
        // ...
    }
}
```

<a id="特殊变量和函数"></a>

### 特殊变量和函数

#### 区块和交易属性

- blockhash(uint blockNumber) returns(bytes32)：返回给定区块号的哈希值，只支持最近的256个区块且不包含当前区块，否则返回0
- block.basefee (uint): 当前区块的基础费用，参考： ([EIP-3198](https://eips.ethereum.org/EIPS/eip-3198) 和 [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559))

- block.chainid (uint): 当前链 id
- block.coinbase(address)：当前块矿工的地址，括号中表示返回值的类型

- block.difficulty(uint)：当前块的难度

- Bock.gaslimit(uint)：当前块的gaslimit

- block.number(uint)：当前区块的块号

- block.timestamp(uint)：当前块的Unix时间戳

- gasleft()(uint256)：获取剩余gas

- msg.data(bytes)：完整的调用数（calldata）

- msg.sender(address)：当前调用发起人的地址

- msg.sig(bytes4)：调用数据（calldata）的前四个字节

- msg.value(uint)：这个消息所附带的以太币。单位为wei
- tx.gasprice(uint)：交易的gas价格

- tx.origin(address)：交易的发送者（全调用链）

#### ABI 编码及解码函数

- `abi.decode(bytes memory encodedData, (...)) returns (...)`: 对给定的数据进行ABI解码，而数据的类型在括号中第二个参数给出 。 例如: `(uint a, uint[2] memory b, bytes memory c) = abi.decode(data, (uint, uint[2], bytes))`
- `abi.encode(...) returns (bytes)`： [ABI](https://learnblockchain.cn/docs/solidity/abi-spec.html#abi) - 对给定参数进行编码
- `abi.encodePacked(...) returns (bytes)`：对给定参数执行 [紧打包编码](https://learnblockchain.cn/docs/solidity/abi-spec.html#abi-packed-mode) ，注意，可以不明确打包编码。
- `abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)`： [ABI](https://learnblockchain.cn/docs/solidity/abi-spec.html#abi) - 对给定第二个开始的参数进行编码，并以给定的函数选择器作为起始的 4 字节数据一起返回
- `abi.encodeWithSignature(string signature, ...) returns (bytes)`：等价于 `abi.encodeWithSelector(bytes4(keccak256(signature), ...)`
- `abi.encodeCall(function functionPointer, (...)) returns (bytes memory)`: 使用tuple类型参数ABI 编码调用 `functionPointer` 。执行完整的类型检查, 确保类型匹配函数签名。结果和 `abi.encodeWithSelector(functionPointer.selector, (...))` 一致。

#### 错误处理

- `assert(bool condition)`:

  如果条件不满足，则使当前交易没有效果 — 用于检查内部错误。

- `require(bool condition)`:

  如果条件不满足则撤销状态更改 - 用于检查由输入或者外部组件引起的错误。

- `require(bool condition, string message)`:

  如果条件不满足则撤销状态更改 - 用于检查由输入或者外部组件引起的错误，可以同时提供一个错误消息。

- `revert()`:

  终止运行并撤销状态更改。

- `revert(string reason)`:

  终止运行并撤销状态更改，可以同时提供一个解释性的字符串。

#### 数学和密码学函数

`addmod(uint x, uint y, uint k) returns (uint)`:

计算 `(x + y) % k`，加法会在任意精度下执行，并且加法的结果即使超过 `2**256` 也不会被截取。从 0.5.0 版本的编译器开始会加入对 `k != 0` 的校验（assert）。

`mulmod(uint x, uint y, uint k) returns (uint)`:

计算 `(x * y) % k`，乘法会在任意精度下执行，并且乘法的结果即使超过 `2**256` 也不会被截取。从 0.5.0 版本的编译器开始会加入对 `k != 0` 的校验（assert）。

`keccak256(...) returns (bytes32)`:

计算 [(tightly packed) arguments](https://solidity-cn.readthedocs.io/zh/develop/abi-spec.html#abi-packed-mode) 的 Ethereum-SHA-3 （Keccak-256）哈希。

`sha256(...) returns (bytes32)`:

计算 [(tightly packed) arguments](https://solidity-cn.readthedocs.io/zh/develop/abi-spec.html#abi-packed-mode) 的 SHA-256 哈希。

`sha3(...) returns (bytes32)`:

等价于 keccak256。

`ripemd160(...) returns (bytes20)`:

计算 [(tightly packed) arguments](https://solidity-cn.readthedocs.io/zh/develop/abi-spec.html#abi-packed-mode) 的 RIPEMD-160 哈希。

`ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)` ：

利用椭圆曲线签名恢复与公钥相关的地址，错误返回零值。

……

#### 地址相关

`<address>.balance` (`uint256`):

以 Wei 为单位的 [地址类型](https://solidity-cn.readthedocs.io/zh/develop/types.html#address) 的余额。

`<address>.transfer(uint256 amount)`:

向 [地址类型](https://solidity-cn.readthedocs.io/zh/develop/types.html#address) 发送数量为 amount 的 Wei，失败时抛出异常，发送 2300 gas 的矿工费，不可调节。

`<address>.send(uint256 amount) returns (bool)`:

向 [地址类型](https://solidity-cn.readthedocs.io/zh/develop/types.html#address) 发送数量为 amount 的 Wei，失败时返回 `false`，发送 2300 gas 的矿工费用，不可调节。

`<address>.call(...) returns (bool)`:

发出低级函数 `CALL`，失败时返回 `false`，发送所有可用 gas，可调节。

`<address>.callcode(...) returns (bool)`：

发出低级函数 `CALLCODE`，失败时返回 `false`，发送所有可用 gas，可调节。

`<address>.delegatecall(...) returns (bool)`:

发出低级函数 `DELEGATECALL`，失败时返回 `false`，发送所有可用 gas，可调节。

#### 合约相关

- `this` (current contract's type):

  当前合约，可以明确转换为 [地址类型](https://solidity-cn.readthedocs.io/zh/develop/types.html#address)。

- `selfdestruct(address recipient)`:

  销毁合约，并把余额发送到指定 [地址类型](https://solidity-cn.readthedocs.io/zh/develop/types.html#address)。

- `suicide(address recipient)`:

  与 selfdestruct 等价，但已不推荐使用。

此外，当前合约内的所有函数都可以被直接调用，包括当前函数。



<a id="智能合约"></a>

## 智能合约

<a id="合约概述"></a>

### 合约概述

Solidity中合约和面向对象语言中的类差不多；

本文结合面向对象语言的特性，讲清楚Solidity语言的多态（Polymorphism）（重写、重载），继承（Inheritance）等特性；

合约包含状态变量（状态变量的数据保存在链上的区块中）及函数；

<a id="创建合约"></a>

### 创建合约

合约通过以太坊交易“从外部”或从 Solidity 合约内部创建合约。

在以太坊上动态地创建合约可以使用 JavaScript API Web3.js的web3.eth.Contract建合约；

当创建一个合约时，它的构造函数(一个用关键字 `constructor` 声明的函数)被执行一次。构造函数是可选的。只允许一个构造函数，这意味着构造函数不支持重载；

构造函数执行完毕后，合约的最终代码将部署到区块链上。此代码包括所有公共和外部函数以及所有可以通过函数调用访问的函数。 部署的代码没有 包括构造函数代码或构造函数调用的内部函数。

如果是一个合约要创立另外一个合约，那么必须要提前知道源代码（被创立的合约的源码和二进制代码）。因此不支持嵌套创建；

```
// 合约内可以通过new关键词来创建一个新合约
contract A{
	uint public x = 0;
	function f(uint a) public returns(uint){
		x = a;
		return x;
	}
}

contract B{
	// 在合约B中创建A合约
	A a = new A();
}
```

```
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.4.22 <0.9.0;

contract OwnedToken {
    // TokenCreator 是后面定义的合约类型.
    // 不创建新合约的话，也可以引用它。
    TokenCreator creator;
    address owner;
    bytes32 name;

    // 这是注册 creator 和设置名称的构造函数。
    constructor(bytes32 name_) {
        // 状态变量通过其名称访问，而不是通过例如 this.owner 的方式访问。
        // 这也适用于函数，特别是在构造函数中，你只能像这样（“内部地”）调用它们，
        // 因为合约本身还不存在。
        owner = msg.sender;
        // 从 `address` 到 `TokenCreator` ，是做显式的类型转换
        // 并且假定调用合约的类型是 TokenCreator，没有真正的方法来检查这一点。
        creator = TokenCreator(msg.sender);
        name = name_;
    }

    function changeName(bytes32 newName) public {
        // 只有 creator （即创建当前合约的合约）能够更改名称 —— 因为合约是隐式转换为地址的，
        // 所以这里的比较是可行的。
        if (msg.sender == address(creator))
            name = newName;
    }

    function transfer(address newOwner) public {
        // 只有当前所有者才能发送 token。
        if (msg.sender != owner) return;
        // 我们也想询问 creator 是否可以发送。
        // 请注意，这里调用了一个下面定义的合约中的函数。
        // 如果调用失败（比如，由于 gas 不足），会立即停止执行。
        if (creator.isTokenTransferOK(owner, newOwner))
            owner = newOwner;
    }
}

contract TokenCreator {
    function createToken(bytes32 name)
    public
    returns (OwnedToken tokenAddress) {
        // 创建一个新的 Token 合约并且返回它的地址。
        // 从 JavaScript 方面来说，返回类型是简单的 `address` 类型，因为
        // 这是在 ABI 中可用的最接近的类型。
        return new OwnedToken(name);
    }

    function changeName(OwnedToken tokenAddress, bytes32 name) 
    public {
        // 同样，`tokenAddress` 的外部类型也是 `address` 。
        tokenAddress.changeName(name);
    }

    function isTokenTransferOK(address currentOwner, address newOwner)
    public
    view
    returns (bool ok){
        // 检查一些任意的情况。
        address tokenAddress = msg.sender;
        return (keccak256(newOwner) & 0xff) == (bytes20(tokenAddress) & 0xff);
    }
}
```

<a id="可见性和getter函数"></a>

### 可见性和 getter 函数

#### 状态变量可见性

状态变量有 3 种可见性：

- `public`

  对于 public 状态变量会自动生成一个 getter 函数（见下面）。 以便其他的合约读取他们的值。 当在用一个合约里使用是，外部方式访问 (如: `this.x`) 会调用getter 函数，而内部方式访问 (如: `x`) 会直接从存储中获取值。 Setter函数则不会被生成，所以其他合约不能直接修改其值。

- `internal`

  内部可见性状态变量只能在它们所定义的合约和派生合同中访问。 它们不能被外部访问。 这是状态变量的默认可见性。

- `private`

  私有状态变量就像内部变量一样，但它们在派生合约中是不可见的。

#### 函数可见性

由于 Solidity 有两种函数调用：外部调用则会产生一个 EVM 调用，而内部调用不会， 更进一步， 函数可以确定器被内部及派生合约的可访问性，这里有 4 种可见性：

##### external （外部的）：可在外部调用，在内部调用，必须使用this关键词

- 外部函数是合约接口的一部分，仅外部访问；

- 所以我们可以从其他合约或通过交易来发起调用；

- 外部函数在接收大的数组数据时更加有效


##### public （公有的）：可在合约内部和外部访问

- public修饰的函数即允许以内部的internal的方式调用，也允许以外部的external的方式调用；

- public修饰的函数，任何用户或者合约都能调用的访问；

- public的函数由于被外部合约访问，是合约对外接口的一部分


##### internal （内部的）：无法在合约外部调用，可以在子类中调用

仅当前合约及所继承的合约，只允许以internal的方式调用；

* virtual 父类 表示允许被重写
* override 子类 表示我重写了父类的方法

##### private （私有的）：只可在合约内部访问

- private仅当前合约内；

- private修饰函数，只能在其所在的合约中调用和访问，即使是其子合约也没有权限访问；

- 即使声明为private，仍能被所有人查看到里面的数据。访问权限只是阻止了其它合约访问函数的修改数据



可见性标识符的定义位置，对于状态变量来说是在类型后面，对于函数是在参数列表和返回关键字中间。

```
pragma solidity  >=0.4.16 <0.9.0;

contract C {
    function f(uint a) private pure returns (uint b) { return a + 1; }
    function setData(uint a) internal { data = a; }
    uint public data;
}
```

在下面的例子中，`D` 可以调用 `c.getData（）` 来获取状态存储中 `data` 的值，但不能调用 `f` 。 合约 `E` 继承自 `C` ，因此可以调用 `compute`。

```
pragma solidity >=0.4.16 <0.9.0;

contract C {
    uint private data;

    function f(uint a) private returns(uint b) { return a + 1; }
    function setData(uint a) public { data = a; }
    function getData() public returns(uint) { return data; }
    function compute(uint a, uint b) internal returns (uint) { return a+b; }
}

// 下面代码编译错误
contract D {
    function readData() public {
        C c = new C();
        uint local = c.f(7); // 错误：成员 `f` 不可见
        c.setData(3);
        local = c.getData();
        local = c.compute(3, 5); // 错误：成员 `compute` 不可见
    }
}

contract E is C {
    function g() public {
        C c = new C();
        uint val = compute(3, 5); // 访问内部成员（从继承合约访问父合约成员）
    }
}
```

#### Getter函数

编译器自动为所有 **public** 状态变量创建 getter 函数。对于下面给出的合约，编译器会生成一个名为 `data` 的函数， 该函数没有参数，返回值是一个 `uint` 类型，即状态变量 `data` 的值。 状态变量的初始化可以在声明时完成。

```
pragma solidity  >=0.4.16 <0.9.0;

contract C {
    uint public data = 42;
}

contract Caller {
    C c = new C();
    function f() public {
        uint local = c.data();
    }
}
```

getter 函数具有外部（external）可见性。如果在内部访问 getter（即没有 `this.` ），它被认为一个状态变量。 如果使用外部访问（即用 `this.` ），它被认作为一个函数。

```
pragma solidity >=0.4.16 <0.9.0;

contract C {
    uint public data;
    function x() public {
        data = 3; // 内部访问
        uint val = this.data(); // 外部访问
    }
}
```

如果你有一个数组类型的 `public` 状态变量，那么你只能通过生成的 getter 函数访问数组的单个元素。 这个机制以避免返回整个数组时的高成本gas。 可以使用如 `myArray(0)` 用于指定参数要返回的单个元素。 如果要在一次调用中返回整个数组，则需要写一个函数，例如：

```
pragma solidity >=0.4.0 <0.9.0;

contract arrayExample {
  // public state variable
  uint[] public myArray;

  // 指定生成的Getter 函数
  /*
  function myArray(uint i) public view returns (uint) {
      return myArray[i];
  }
  */

  // 返回整个数组
  function getArray() public view returns (uint[] memory) {
      return myArray;
  }
}
```

现在可以使用 `getArray()` 获得整个数组，而 `myArray(i)` 是返回单个元素。

<a id="函数修改器"></a>

### 函数修改器

修改器（modifier），可以用来轻易的改变一个函数的行为，控制函数的逻辑，比如用于在函数执行前检查某种前置条件

修改器是一种合约属性，可以被继承，同时还可被派生的合约重写（override）

关键字：modifier

格式：

```
modifier 函数修改器名(参数){
	a++;	// 代表函数前执行的代码
	_;		// 表示被修饰的函数中的代码
	a--;	// 代表函数后执行的代码
}
```

对于一个函数可以有多个修改器限制，在函数定义的时候依次写上，并用加空格分隔，执行的时候也是依次执行，多个修改器是同时限制，也就是说必须满足所有修改器的权限，才可以执行函数体的代码。

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract FunctionModifier {
    // We will use these variables to demonstrate how to use
    // modifiers.
    address public owner;
    uint public x = 10;
    bool public locked;

    constructor() {
        // Set the transaction sender as the owner of the contract.
        owner = msg.sender;
    }

    // Modifier to check that the caller is the owner of
    // the contract.
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        // Underscore is a special character only used inside
        // a function modifier and it tells Solidity to
        // execute the rest of the code.
        _;
    }

    // Modifiers can take inputs. This modifier checks that the
    // address passed in is not the zero address.
    modifier validAddress(address _addr) {
        require(_addr != address(0), "Not valid address");
        _;
    }

    function changeOwner(address _newOwner) public onlyOwner validAddress(_newOwner) {
        owner = _newOwner;
    }

    // Modifiers can be called before and / or after a function.
    // This modifier prevents a function from being called while
    // it is still executing.
    modifier noReentrancy() {
        require(!locked, "No reentrancy");
        locked = true;
        _;
        locked = false;
    }

    function decrement(uint i) public noReentrancy {
        x -= i;
        if (i > 1) {
            decrement(i - 1);
        }
    }
}
```

如果同一个函数有多个 修饰器modifier，它们之间以空格隔开，修饰器modifier 会依次检查执行。

修饰器modifier 或函数体中显式的 return 语句仅仅跳出当前的 修饰器modifier 和函数体。 返回变量会被赋值，但整个执行逻辑会从前一个 修饰器modifier 中的定义的 “_” 之后继续执行。

修饰器modifier 的参数可以是任意表达式，在此上下文中，所有在函数中可见的符号，在 修饰器modifier 中均可见。 在 修饰器modifier 中引入的符号在函数中不可见（可能被重载改变）。

<a id="Constant和Immutable状态变量"></a>

### Constant 和 Immutable 状态变量

状态变量声明为 `constant` (常量)或者 `immutable` （不可变量），在这两种情况下，合约一旦部署之后，变量将不在修改。

对于 `constant` 常量, 他的值在编译器确定，而对于 `immutable`, 它的值在部署时确定。

也可以在文件级别定义 `constant` 变量（注：0.7.2 之后加入的特性）。

编译器不会为这些变量预留存储位，它们的每次出现都会被替换为相应的常量表达式（它可能被优化器计算为实际的某个值）。

与常规状态变量相比，常量和不可变量的gas成本要低得多。 对于常量，赋值给它的表达式将复制到所有访问该常量的位置，并且每次都会对其进行重新求值。 这样可以进行本地优化。

不可变变量在构造时进行一次求值，并将其值复制到代码中访问它们的所有位置。 对于这些值，将保留32个字节，即使它们适合较少的字节也是如此。 因此，常量有时可能比不可变量更便宜。

不是所有类型的状态变量都支持用 constant 或 `immutable` 来修饰，当前仅支持 [字符串](https://learnblockchain.cn/docs/solidity/types.html#strings) (仅常量) 和 [值类型](https://learnblockchain.cn/docs/solidity/types.html#value-types) .

```
// SPDX-License-Identifier: GPL-3.0
pragma solidity >0.7.4;
uint constant X = 32**22 + 8;

contract C {

    string constant TEXT = "abc";
    bytes32 constant MY_HASH = keccak256("abc");
    uint immutable decimals;
    uint immutable maxBalance;
    address immutable owner = msg.sender;

    constructor(uint decimals_, address ref) {
        decimals = decimals_;
        // Assignments to immutables can even access the environment.
        maxBalance = ref.balance;
    }

    function isBalanceTooHigh(address _other) public view returns (bool) {
        return _other.balance > maxBalance;
    }
}
```

#### Constant

如果状态变量声明为 `constant` (常量)。在这种情况下，只能使用那些在编译时有确定值的表达式来给它们赋值。 任何通过访问 storage，区块链数据（例如 `block.timestamp`, `address(this).balance` 或者 `block.number`）或执行数据（ `msg.value` 或 `gasleft()` ） 或对外部合约的调用来给它们赋值都是不允许的。

允许可能对内存分配产生副作用（side-effect）的表达式，但那些可能对其他内存对象产生副作用的表达式则不允许。

内建（built-in）函数 `keccak256` ， `sha256` ， `ripemd160` ， `ecrecover` ， `addmod` 和 `mulmod` 是允许的（即使他们确实会调用外部合约， `keccak256` 除外）。

允许内存分配器的副作用的原因是它可以构造复杂的对象，例如： 查找表（lookup-table）。 此功能尚不完全可用。

#### Immutable

声明为不可变量(`immutable`)的变量的限制要比声明为常量(`constant`) 的变量的限制少：可以在合约的构造函数中或声明时为不可变的变量分配任意值。 不可变量只能赋值一次，并且在赋值之后才可以读取。

编译器生成的合约创建代码将在返回合约之前修改合约的运行时代码，方法是将对不可变量的所有引用替换为分配给它们的值。 如果要将编译器生成的运行时代码与实际存储在区块链中的代码进行比较，则这一点很重要。

注解

<a id="构造函数"></a>

### 构造函数

构造函数也叫“构造器”，通常用来完成合约的初始化变量赋值；

它是一个可选函数，构造函数使用关键词 constructor来表示；

如果没有实现构造函数，那合约会添加一个默认的构造函数；

当创建一个合约时，它的构造函数被执行一次。构造函数是可选的，只允许一个构造函数，这意味着构造函数不支持重载；

合约部署时，自动调用构造函数创建合约；

可以在创建合约中发送ether,但不能限制gas。如果创建发生out-of-stack或无足够的余额，则会抛出一个异常

```
constructor() public{

}
```

<a id="函数"></a>

### 函数

可以在合约内部和外部定义函数。

合约之外的函数（也称为“自由函数”）始终具有隐式的 `internal` [可见性](https://learnblockchain.cn/docs/solidity/contracts.html#visibility-and-getters)。 它们的代码包含在所有调用它们合约中，类似于内部库函数。

```
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.1 <0.9.0;

function sum(uint[] memory arr) pure returns (uint s) {
    for (uint i = 0; i < arr.length; i++)
        s += arr[i];
}

contract ArrayExample {
    bool found;
    function f(uint[] memory arr) public {
        // This calls the free function internally.
        // The compiler will add its code to the contract.
        uint s = sum(arr);
        require(s >= 10);
        found = true;
    }
}
```

#### 函数参数与返回值

与 Javascript 一样，函数可能需要参数作为输入; 而与 Javascript 和 C 不同的是，它们可能返回任意数量的参数作为输出。

##### 函数参数（输入参数）

函数参数的声明方式与变量相同。不过未使用的参数可以省略参数名。

例如，如果我们希望合约接受有两个整数形参的函数的外部调用，可以像下面这样写：

```
pragma solidity >=0.4.16 <0.9.0;

contract Simple {
    uint sum;
    function taker(uint a, uint b) public {
        sum = a + b;
    }
}
```

函数参数可以当作为本地变量，也可用在等号左边被赋值。

##### 返回变量

函数返回变量的声明方式在关键词 `returns` 之后，与参数的声明方式相同。

例如，如果我们需要返回两个结果：两个给定整数的和与积，我们应该写作：

```
pragma solidity >=0.4.16 <0.9.0;

contract Simple {
    function arithmetic(uint a, uint b)
        public
        pure
        returns (uint sum, uint product)
    {
        sum = a + b;
        product = a * b;
    }
}
```

返回变量名可以被省略。 返回变量可以当作为函数中的本地变量，没有显式设置的话，会使用 :ref:` 默认值 <default-value>` 返回变量可以显式给它附一个值(像上面)，也可以使用 `return` 语句指定，使用 `return` 语句可以一个或多个值，参阅 [multiple ones](https://learnblockchain.cn/docs/solidity/contracts.html#multi-return) 。

```
pragma solidity >=0.4.16 <0.9.0;

contract Simple {
    function arithmetic(uint a, uint b)
        public
        pure
        returns (uint sum, uint product)
    {
        return (a + b, a * b);
    }
}
```

这个形式等同于赋值给返回参数，然后用 `return;` 退出。

如果使用 `return` 提前退出有返回值的函数， 必须在用 return 时提供返回值。

##### 返回多个值

当函数需要使用多个值，可以用语句 `return (v0, v1, ..., vn)` 。 参数的数量需要和声明时候一致。

#### 状态可变性

##### View 函数

可以将函数声明为 `view` 类型，这种情况下要保证不修改状态。

下面的语句被认为是修改状态：

1. 修改状态变量。
2. 产生事件。
3. 创建其它合约。
4. 使用 `selfdestruct`。
5. 通过调用发送以太币。
6. 调用任何没有标记为 `view` 或者 `pure` 的函数。
7. 使用低级调用。
8. 使用包含特定操作码的内联汇编。

```
pragma solidity ^0.4.16;

contract C {
    function f(uint a, uint b) public view returns (uint) {
        return a * (b + 42) + now;
    }
}
```

##### Pure 函数

函数可以声明为 `pure` ，在这种情况下，承诺不读取或修改状态。

除了上面解释的状态修改语句列表之外，以下被认为是从状态中读取：

1. 读取状态变量。
2. 访问 `this.balance` 或者 `<address>.balance`。
3. 访问 `block`，`tx`， `msg` 中任意成员 （除 `msg.sig` 和 `msg.data` 之外）。
4. 调用任何未标记为 `pure` 的函数。
5. 使用包含某些操作码的内联汇编。

```
pragma solidity ^0.4.16;

contract C {
    function f(uint a, uint b) public pure returns (uint) {
        return a * (b + 42);
    }
}
```

#### 特别的函数

##### receive 接收以太函数

一个合约最多有一个 `receive` 函数, 声明函数为： `receive() external payable { ... }`

不需要 `function` 关键字，也没有参数和返回值并且必须是　`external`　可见性和　`payable` 修饰． 它可以是 `virtual` 的，可以被重载也可以有 修改器modifier 。

在对合约没有任何附加数据调用（通常是对合约转账）是会执行 `receive` 函数．　例如　通过 `.send()` or `.transfer()` 如果 `receive` 函数不存在，　但是有payable　的 [fallback 回退函数](https://learnblockchain.cn/docs/solidity/contracts.html#fallback-function) 那么在进行纯以太转账时，fallback 函数会调用．

如果两个函数都没有，这个合约就没法通过常规的转账交易接收以太（会抛出异常）．

更糟的是，`receive` 函数可能只有 2300 gas 可以使用（如，当使用 `send` 或 `transfer` 时）， 除了基础的日志输出之外，进行其他操作的余地很小。下面的操作消耗会操作 2300 gas :

- 写入存储
- 创建合约
- 调用消耗大量 gas 的外部函数
- 发送以太币

下面是一个例子：

```
pragma solidity ^0.6.0;

// 这个合约会保留所有发送给它的以太币，没有办法取回。
contract Sink {
    event Received(address, uint);
    receive() external payable {
        emit Received(msg.sender, msg.value);
    }
}
```

##### Fallback 回退函数

合约可以最多有一个回退函数。函数声明为： `fallback () external [payable]` 或 `fallback (bytes calldata input) external [payable] returns (bytes memory output)`

没有　`function`　关键字。　必须是　`external`　可见性，它可以是 `virtual` 的，可以被重载也可以有 修改器modifier 。

如果在一个对合约调用中，没有其他函数与给定的函数标识符匹配fallback会被调用． 或者在没有 [receive 函数](https://learnblockchain.cn/docs/solidity/contracts.html#receive-ether-function)　时，而没有提供附加数据对合约调用，那么fallback 函数会被执行。

fallback　函数始终会接收数据，但为了同时接收以太时，必须标记为　`payable` 。

如果使用了带参数的版本， `input` 将包含发送到合约的完整数据（等于 `msg.data` ），并且通过 `output` 返回数据。 返回数据不是 ABI 编码过的数据，相反，它返回不经过修改的数据。

更糟的是，如果回退函数在接收以太时调用，可能只有 2300 gas 可以使用，参考　[receive接收函数](https://learnblockchain.cn/docs/solidity/contracts.html#receive-ether-function)

与任何其他函数一样，只要有足够的 gas 传递给它，回退函数就可以执行复杂的操作。

```
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.6.2 <0.9.0;

contract Test {
    // 发送到这个合约的所有消息都会调用此函数（因为该合约没有其它函数）。
    // 向这个合约发送以太币会导致异常，因为 fallback 函数没有 `payable` 修饰符
    fallback() external { x = 1; }
    uint x;
}

// 这个合约会保留所有发送给它的以太币，没有办法返还。
contract TestPayable {
    uint x;
    uint y;

    // 除了纯转账外，所有的调用都会调用这个函数．
    // (因为除了 receive 函数外，没有其他的函数).
    // 任何对合约非空calldata 调用会执行回退函数(即使是调用函数附加以太).
    fallback() external payable { x = 1; y = msg.value; }

    // 纯转账调用这个函数，例如对每个空empty calldata的调用
    receive() external payable { x = 2; y = msg.value; }
}

contract Caller {
    function callTest(Test test) public returns (bool) {
        (bool success,) = address(test).call(abi.encodeWithSignature("nonExistingFunction()"));
        require(success);
        //  test.x 结果变成 == 1。

        // address(test) 不允许直接调用 ``send`` ,  因为 ``test`` 没有 payable 回退函数
        //  转化为 ``address payable`` 类型 , 然后才可以调用 ``send``
        address payable testPayable = payable(address(test));


        // 以下将不会编译，但如果有人向该合约发送以太币，交易将失败并拒绝以太币。
        // test.send(2 ether）;
    }

    function callTestPayable(TestPayable test) public returns (bool) {
        (bool success,) = address(test).call(abi.encodeWithSignature("nonExistingFunction()"));
        require(success);
        // 结果 test.x 为 1  test.y 为 0.
        (success,) = address(test).call{value: 1}(abi.encodeWithSignature("nonExistingFunction()"));
        require(success);
        // 结果test.x 为1 而 test.y 为 1.

        // 发送以太币, TestPayable 的 receive　函数被调用．

        // 因为函数有存储写入, 会比简单的使用 ``send`` or ``transfer``消耗更多的 gas。
        // 因此使用底层的call调用
        (success,) = address(test).call{value: 2 ether}("");
        require(success);

        // 结果 test.x 为 2 而 test.y 为 2 ether.

        return true;
    }
}
```

#### 函数重载

合约可以具有多个不同参数的同名函数，称为“重载”（overloading），这也适用于继承函数。以下示例展示了合约 `A` 中的重载函数 `f`。

```
pragma solidity >=0.4.16 <0.9.0;

contract A {
    function f(uint value) public pure returns (uint out) {
        out = value;
    }

    function f(uint value, bool really) public pure returns (uint out) {
        if (really)
            out = value;
    }
}
```

重载函数也存在于外部接口中。如果两个外部可见函数仅区别于 Solidity 内的类型而不是它们的外部类型则会导致错误。

```
// 以下代码无法编译
pragma solidity >=0.4.16 <0.9.0;

contract A {
    function f(B value) public pure returns (B out) {
        out = value;
    }

    function f(address value) public pure returns (address out) {
        out = value;
    }
}

contract B {
}
```

以上两个 `f` 函数重载都接受了 ABI 的地址类型，虽然它们在 Solidity 中被认为是不同的。

##### 重载解析和参数匹配

通过将当前范围内的函数声明与函数调用中提供的参数相匹配，可以选择重载函数。 如果所有参数都可以隐式地转换为预期类型，则选择函数作为重载候选项。如果一个候选都没有，解析失败。

注解

返回参数不作为重载解析的依据。

```
pragma solidity >=0.4.16 <0.9.0;

contract A {
    function f(uint8 val) public pure returns (uint8 out) {
        out = val;
    }

    function f(uint256 val) public pure returns (uint256 out) {
        out = val;
    }
}
```

调用 `f(50)` 会导致类型错误，因为 `50` 既可以被隐式转换为 `uint8` 也可以被隐式转换为 `uint256`。 另一方面，调用 `f(256)` 则会解析为 `f(uint256)` 重载，因为 `256` 不能隐式转换为 `uint8`。

### 事件（event）、日志（log）

事件event是以太坊提供的基本功能，用于将数据记录成日志保存到区块链上，用户可以自定义需要记录的数据，以及主题（topic）和索引；

日志是指事件保存在区块链上的数据；

事件强调操作行为，日志强调存储内容，两者是完全不同的概念；

事件在合约中可以被继承

在DAPP的应用中，如果监听了某事件，当事件发生时，会进行回调；

#### 创建事件

solidity中，使用关键字event来定义事件，其中参数列表就是需要保存到区块链上的数据。

```
contract createEvent{
	string public name;
	uint public age;
	event log(string _name, uint _age);
	function emitEvent() public {
		name = "lisi";
		age = 23;
		emit log(name, age)
	}
}
```

#### 触发事件

触发一个事件使用 emit

当定义的事件触发时，我们可以将事件存储到EVM的交易日志中，日志是区块链中的一种特殊数据结构；

日志与合约关联，与合约的存储合并存入区块链中；只要某个区块可以访问，其相关的日志就可以访问。但在合约中，我们不能直接访问日志和事件数据

可以通过日志实现简单支付验证SPV，如果一个外部实体提供了一个带有这种证明的合约，它可以检查日志是否真实存在于区块链中。

### 继承

Solidity中合约继承是扩展合约功能的一种方式；

Solidity继承使用的是关键词 **is**

继承的本质：继承的实现方案是代码拷贝，所以合约继承后，部署到网络时，将变成一个合约。代码将从父类拷贝到子类中。

合约继承的重要特点：

* 派生合约可以访问父合约的所有非私有成员，包括内部方法和状态变量。但是不允许使用**this**；
* 如果函数签名保持不变，则允许函数重写。如果输出参数不同，编译将失败；
* 可以使用super关键字或父合同名称调用父合同的函数；
* 在多重继承的情况下，使用super的父合约函数调用，优先选择被最多继承的合约

##### 单继承

```
contract Father{
	uint public money = 100;
}

contract Son is Father{

}
```

##### 继承的可见性

* 子合约不能访问父合约的private私有成员
* 子合约可以访问父合约所有的非私有成员（包含internal的函数和状态变量）

##### 父合约构造函数的传参

派生的合约需要调用所有父合约的构造函数，并且需要提供所有父合约需要的参数

继承的子合约，必须提供父合约构造方法需要的所有参数，有两种方式实现，如下：

* 一种称为“继承列表”式
  * 即直接在继承列表中使用 is Base（参数）
  * 此种方式对于构造器是常量的情况比较方便，可以直接说明合约的行为；
* 另一种称为“修改器风格”式
  * Base(_y*_y)就像是一个函数修改器,它会作为修饰派生构造函数的一部分得到执行
  * 此种方式适合于构造的参数值是由派生合约指定的情况

##### 重写

合约继承后，状态变量覆盖被视为错误；

派生合约不可以在声明已经是基类合约中可见的状态变量具有相同的名称。即状态变量不允许重写；

在子合约中允许重写函数，但不允许重写返回参数签名，即返回值类型不能修改；

##### Super 关键词

Solidity支持多重继承包括多态。所有的函数调用都是虚拟的，这意味着最终派生的函数会被调用，除非明确给出合约名称或者使用super关键字；

当一个合约从多个合约继承时，在区块链上只有一个合约被创建，所有基类合约（或称为父合约）的代码被编译到创建的合约中。这意味着对基类合约函数的所有内部调用也只是使用内部函数调用；

合约继承后，状态变量覆盖被视为错误。派生合约不可以在声明已经是基类合约中可见的状态变量具有相同的名称；

使用super可以访问父合约的函数，不能访问状态变量

##### 多继承

一个合约可以继承多个合约，用逗号分开；

如果继承的合约之间也有父子关系，那么合约要按照先父到子的顺序排序

```
contract X {}
contract A is X {}
contract C is X,A{} //先X，再A
```

当继承多个合约时，这些父合约中不允许出现相同的状态变量名

当继承多个合约时，这些父合约中允许出现相同的函数名，事件名，修改器名或相互重名

##### modifier函数修饰器的继承

合约时可以继承的，在子合约中我们还可以对父合约中的修改器进行重写覆盖

```
// 方法上加上virtual关键词，重写的方法加上override方法
contract Bank{
	modifier transferLimit(uint _withdraw) virtual{
		require(_withdraw > 100);
		_;
	}
}
contract ModifierOverride is Bank{
	modifier transferLimit(uint _withdraw) override{
		require(_withdraw > 10);
		_;
	}
}
```

#### 多态

##### 重载

重载的定义：

* 方法名相同
* 方法形参的个数或类型不同
* 方法返回值的类型不作为函数是否是重载的依据

合约可以有多个同名但不同输入参数的函数，这也适用于继承的函数；

在外部接口中也存在重载的函数。如果两个外部可见的函数的Solidity类型不同，但外部类型相同，不能成功重载；

#### 抽象合约（abstract）

抽象合约和其他语言里的抽象类是类似的，它是一个合约中没有函数体（实现）的函数（函数直接以；结尾）的合约。下面就是一个抽象合约。

```
abstract contract Feline{
	function sound() public virtual returns(string memory);
}
contract Cat is Feline{
	function sound() public pure override returns(string memory){
		return "miao miao";
	}
}
```

#### 接口（interface）

接口和抽象合约类似，与之不同的是，接口内没有任何函数是已实现的，同时还有以下限制：

* 不能继承其他合约或接口
* 不能定义构造器
* 不能定义变量
* 不能定义结构体
* 不能定义枚举类

注意：其中一些限制可能在未来放开。

接口被限制为合约ABI定义可以表示的内容，ABI和接口定义之间应该可以进行转换而不会有任何信息丢失。接口声明用关键词interface表示。

```
interface Bank{
	function saveMoney(uint _money) external;
	function withdrawMoney(uint _money) external returns(uint);
}
contract ICBCBank is Bank{
	uint public money;
	function saveMoney(uint _money) external override{
		money = money + _money;
	}
	function withdrawMoney(uint _money) external override returns(uint){
		money = money - _money;
		return money;
	}
}
```

#### 库（library）

库和合约类似，它也部署在一个指定的地址上，然后通过EVM的特性DELEGATECALL来复用代码。

对比普通合约来说，库有以下的限制（这些限制也可能在未来的版本中解除）：

* 无状态变量
* 不能继承或被继承
* 不能接收以太币
* 不能销毁一个库

```
library CommonMethod{
	function sum(uint a, uint b) public pure returns(uint){
		return a + b;
	}
	function sub(uint a, uint b) public pure returns(uint){
		return a - b;
	}
}

contract DemoLibraryContract{
	function runMethod() public pure returns(uint, uint){
		return (CommonMethod.sum(100,200), CommonMethod.sub(400,300));
	}
}
```

##### Using for 指令

指令using X for X 来把库函数（从库A）关联到类型B。这些函数将会把调用函数的实例作为第一个参数。

```
import "./CommonMethod.sol";

contract DemoLibraryContract{
	using CommonMethod for uint;
	uint number = 100;
	function runSum() public view returns(uint){
		return number.sum(100);
	}
	function runSub() public view returns(uint){
		return number.sub(10);
	}
}
```



#### ETH支付

##### 支付ETH

如果在函数中涉及到以太币的转移，需要使用到payable关键词。意味着可以在调用这笔函数的消息中附带以太币。

```
contract Payable{
    address payable public owner;

    constructor(){
        owner = payable(msg.sender);
    }

    function deposit() external payable{}

    function getBalance() external view returns(uint){
        return address(this).balance;
    }
}
```

##### 回退函数

```
contract Fallback{
    event Log(string func, address sender, uint value, bytes data);

    fallback() external payable{
        emit Log("fallback", msg.sender, msg.value, msg.data);
    }

    receive() external payable{
        emit Log("receive", msg.sender, msg.value, "");
    }
}
```

##### 合约发送ETH

三种方式：

* transfer：2300gas，reverts 直接返回
* send：2300gas，返回bool
* call：all gas，返回bool与data

让合约获取主币两种方式：

* ```
  constructor() payable {}
  ```

* ```
  receive external payable{}
  ```

```
contract SendEth{
    constructor() payable {}

    receive() external payable{}

    function sendViaTransfer(address payable _to) external payable{
        _to.transfer(123);
    }

    function sendViaSend(address payable _to) external payable{
        bool sent = _to.send(456);
        require(sent, "send failed");
    }

    function sendViaCall(address payable _to) external payable{
        (bool success,) = _to.call{value: 789}("");
        require(success, "call failed");
    }

    function getBalance() external view returns(uint){
        return address(this).balance;
    }
}

contract EthReceiver{
    event Log(uint _amount, uint _gas);
    receive() external payable{
        emit Log(msg.value, gasleft());
    }
} 
```

#### 调用其他合约

#### 接口合约

#### 低级call

#### 委托调用

#### 工厂合约

#### 库合约





