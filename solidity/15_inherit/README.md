### 继承

就像Java、C++中，类的继承一样，Solidity中，合约继承是扩展合约功能的一种方式。Solidity支持单继承和多继承。Solidity中，合约继承的重要特点：

- 派生合约可以访问父合约的所有非私有成员，包括内部方法和状态变量。但是不允许使用**this**。
- 如果函数签名保持不变，则允许函数重写。如果输出参数不同，编译将失败。
- 可以使用**super**关键字或父合同名称调用父合同的函数。
- 在多重继承的情况下，使用**super**的父合约函数调用，优先选择被最多继承的合约。

#### 单继承

```
contract Father{
	uint public money = 100;
}

contract Son is Father{

}
```

#### 继承的可见性

* 子合约不能访问父合约的private私有成员
* 子合约可以访问父合约所有的非私有成员（包含internal的函数和状态变量）

#### 父合约构造函数的传参

派生的合约需要调用所有父合约的构造函数，并且需要提供所有父合约需要的参数

继承的子合约，必须提供父合约构造方法需要的所有参数，有两种方式实现，如下：

* 一种称为“继承列表”式
  * 即直接在继承列表中使用 is Base（参数）
  * 此种方式对于构造器是常量的情况比较方便，可以直接说明合约的行为；
* 另一种称为“修改器风格”式
  * Base(_y*_y)就像是一个函数修改器,它会作为修饰派生构造函数的一部分得到执行
  * 此种方式适合于构造的参数值是由派生合约指定的情况

#### 重写

合约继承后，状态变量覆盖被视为错误；

派生合约不可以在声明已经是基类合约中可见的状态变量具有相同的名称。即状态变量不允许重写；

在子合约中允许重写函数，但不允许重写返回参数签名，即返回值类型不能修改；

#### Super 关键词

Solidity支持多重继承包括多态。所有的函数调用都是虚拟的，这意味着最终派生的函数会被调用，除非明确给出合约名称或者使用super关键字；

当一个合约从多个合约继承时，在区块链上只有一个合约被创建，所有基类合约（或称为父合约）的代码被编译到创建的合约中。这意味着对基类合约函数的所有内部调用也只是使用内部函数调用；

合约继承后，状态变量覆盖被视为错误。派生合约不可以在声明已经是基类合约中可见的状态变量具有相同的名称；

使用super可以访问父合约的函数，不能访问状态变量

#### 多继承

一个合约可以继承多个合约，用逗号分开；

如果继承的合约之间也有父子关系，那么合约要按照先父到子的顺序排序

```
contract X {}
contract A is X {}
contract C is X,A{} //先X，再A
```

当继承多个合约时，这些父合约中不允许出现相同的状态变量名

当继承多个合约时，这些父合约中允许出现相同的函数名，事件名，修改器名或相互重名

#### modifier函数修饰器的继承

合约时可以继承的，在子合约中我们还可以对父合约中的修改器进行重写覆盖

```
// 方法上加上virtual关键词，重写的方法加上override方法
contract Bank{
	modifier transferLimit(uint _withdraw) virtual{
		require(_withdraw > 100);
		_;
	}
}
contract ModifierOverride is Bank{
	modifier transferLimit(uint _withdraw) override{
		require(_withdraw > 10);
		_;
	}
}
```

#### 